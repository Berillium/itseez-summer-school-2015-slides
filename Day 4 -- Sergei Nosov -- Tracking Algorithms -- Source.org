#+OPTIONS: toc:nil num:nil ^:nil reveal_mathjax:t reveal_single_file:t
#+REVEAL_ROOT: ./reveal.js
#+REVEAL_THEME: league
#+REVEAL_MARGIN: 0
#+REVEAL_MIN_SCALE: 0.1
#+REVEAL_MAX_SCALE: 1.5

* Трекинг

#+ATTR_HTML: :align center
[[file:media/title.jpg]]

* Правильный трекинг!

#+ATTR_HTML: :align center
[[file:media/title_red.jpg.png]]

* Обзор

- Классификация трекеров
- Методы оценки качества
- Практическая работа: Median Flow

* Классификация трекеров

** Пишем свой трекер

0. Представление объекта

** Представление объекта

#+ATTR_HTML: :align center
[[file:media/representation.png]]

** Пишем свой трекер

1. Представление объекта

2. Сравнение кандидата с искомым объектом
   #+ATTR_REVEAL: :frag roll-in
   - Дискриминативные

3. Поиск кандидатов и выбор лучшего
   #+ATTR_REVEAL: :frag roll-in
   - Генеративные

** Дискриминативные трекеры

Из любого классификатора можно сделать дискриминативный трекер.

1. /Вход - единственный позитивный сэмпл./
   Где брать ещё? Что делать с неправильно выбранными?
2. /Обучение on-line./
   FPS?
3. /Распознавание on-line./
   Кто выбирает кандидатов? Сколько их будет?

** Brute-Force Winner-Takes-All

1. Используется единственный известный сэмпл
2. Обучения нет
3. Кандидаты
   1. Все возможные прямоугольники (brute-force)
   2. Сравниваются при помощи SAD (SSD, цветовых гистограмм и проч.)
   3. Побеждает лучший (winner-takes-all)

** Генеративные трекеры

Предлагают "хитрую" процедуру поиска кандидатов и выбора среди них
лучшего.

- Median flow
- Mean-shift
- Particle filter
- etc.

* Median flow

- Надстройка над optical flow
- Сопровождает объекты, а не отдельные точки
- Использует Forward-Backward error для дополнительной фильтрации точек и
  детекции срыва трекинга

** Первое приближение

[[./media/flow.jpg]]

- Выбрать точки в прямоугольнике
- Вычислить для них optical flow (и отбросить "плохие")
- Взять медианные смещения по X и по Y

** Проблемы

#+ATTR_HTML: :align center :width 200%
[[./media/fb.png]]

** Forward-backward error

Смещение точки от предыдущего кадра к следующему должно соответствовать
обратному смещению - от следующего к предыдущему.

- Вычислить optical flow в обратном направлении
- Отфильтровать точки - если положение оригинальной точки и её образа,
  вычисленного с помощью forward-backward flow "сильно" отличаются, её нужно
  отбросить

** Фильтрация "плохих" точек

- Найти медианную ошибку
- Назначить "плохими" все точки с большей ошибкой

** Оценка масштаба

- Для всех пар точек нужно определить отношение расстояния между ними на
  предыдущем и следующем кадре
- Выбрать медианное отношение

** Полный алгоритм

- Выбрать точки в прямоугольнике
- Вычислить для них optical flow (и отбросить "плохие")
- /Вычислить обратный optical flow/ (и отбросить плохие по forward-backward
  правилу)
- Взять медианные смещения по X и по Y
- /Оценить масштаб/

** Вариации

- Использовать разные стратегии выбора начальных точек
  - Равномерно распределенные
  - Harris corners
  - goodFeaturesToTrack
  - SIFT/SURF/ORB features
- Использовать другие алгоритмы фильтрации
  - Фиксированный порог
  - Среднее
- Детектировать срыв трекинга

* Оценка качества трекинга

$precision = \frac{\text{количество правильных предсказаний}}{\text{количество предсказаний}}$

$recall = \frac{\text{количество правильных предсказаний}}{\text{количество кадров с объектом}}$

* Составные трекеры

- Дискриминативные трекеры, как правильно, имеют хороший precision
- Генеративные - хороший recall
- Все "серьезные" современные трекеры имеют нетривиальные дискриминативные и
  генеративные части

* Вопросы?
